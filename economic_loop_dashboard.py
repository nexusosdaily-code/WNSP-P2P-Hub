"""
NexusOS Economic Loop Dashboard
=================================

Visualizes the complete economic cycle:
ğŸ“¨ Messaging Burns â†’ âš›ï¸ Orbital Transitions â†’ ğŸ’§ DEX Liquidity â†’ 
ğŸ­ Supply Chain Value â†’ ğŸ¤ Community Ownership â†’ ğŸŒ Global Debt â†’ ğŸ›¡ï¸ F_floor Protection

This dashboard shows how messaging IS the economy in NexusOS.
"""

import streamlit as st
import plotly.graph_objects as go
import plotly.express as px
from typing import Dict, Any
import time

from native_token import NativeTokenSystem
from economic_loop_controller import (
    get_economic_loop,
    IndustryProductivity,
    SpectralRegion
)


def render_economic_loop_dashboard():
    """Main economic loop dashboard"""
    
    st.title("ğŸ’« NexusOS Economic Loop")
    st.markdown("""
    **The Complete Economic Cycle:** Messaging drives the entire civilization economy  
    *Every message sent creates real economic value through physics-based orbital transitions*
    """)
    
    # Initialize token system and economic loop
    if 'token_system' not in st.session_state:
        st.session_state.token_system = NativeTokenSystem(initial_supply=1_000_000)
    
    token_system = st.session_state.token_system
    economic_loop = get_economic_loop(token_system)
    
    # Get complete loop status
    loop_status = economic_loop.get_complete_loop_status()
    
    # Header metrics
    render_header_metrics(loop_status)
    
    st.divider()
    
    # Tabs for different views
    tabs = st.tabs([
        "ğŸ’« Loop Overview",
        "ğŸ“¨ Messaging â†’ Reserve",
        "ğŸ’§ Reserve â†’ DEX",
        "ğŸ­ Supply Chain Value",
        "ğŸ¤ Community Ownership",
        "ğŸ›¡ï¸ Crisis Protection",
        "ğŸ’° Money Flow Diagram"
    ])
    
    with tabs[0]:
        render_loop_overview(economic_loop, loop_status)
    
    with tabs[1]:
        render_messaging_flow_tab(economic_loop)
    
    with tabs[2]:
        render_reserve_dex_tab(economic_loop)
    
    with tabs[3]:
        render_supply_chain_tab(economic_loop)
    
    with tabs[4]:
        render_community_ownership_tab(economic_loop)
    
    with tabs[5]:
        render_crisis_protection_tab(economic_loop)
    
    with tabs[6]:
        render_money_flow_diagram()


def render_header_metrics(loop_status: Dict[str, Any]):
    """Render key economic loop metrics"""
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        reserve_nxt = loop_status['reserve_balance']['total_energy_nxt']
        st.metric(
            "ğŸ’° Transition Reserve",
            f"{reserve_nxt:.2f} NXT",
            help="Energy from message burns stored as orbital transitions"
        )
    
    with col2:
        dex_allocated = loop_status['dex_allocations']['total_nxt_allocated']
        st.metric(
            "ğŸ’§ DEX Liquidity",
            f"{dex_allocated:.2f} NXT",
            help="Reserve energy allocated to supply-chain liquidity pools"
        )
    
    with col3:
        supply_value = loop_status['supply_chain_value']
        st.metric(
            "ğŸ­ Supply Chain Value",
            f"{supply_value:.6f} NXT",
            help="NXT value generated by real industry productivity"
        )
    
    with col4:
        community_invested = loop_status['community_ownership']['total_invested_nxt']
        st.metric(
            "ğŸ¤ Community Ownership",
            f"{community_invested:.2f} NXT",
            help="Total NXT invested by community in liquidity pools"
        )


def render_loop_overview(economic_loop, loop_status: Dict[str, Any]):
    """Overview of complete economic loop"""
    
    st.subheader("ğŸ’« Complete Economic Loop Status")
    
    st.info("""
    ### ğŸŒŠ How the Loop Works:
    
    1. **ğŸ“¨ User sends message** â†’ Burns NXT tokens
    2. **âš›ï¸ Orbital transition** â†’ Energy flows to TRANSITION_RESERVE
    3. **ğŸ’§ Reserve allocation** â†’ Energy distributed to DEX pools based on supply chain demand
    4. **ğŸ­ Supply chain activity** â†’ Manufacturing, logistics generate real NXT value
    5. **ğŸ¤ Community invests** â†’ Liquidity providers own physics-backed stakes
    6. **ğŸŒ Global debt backing** â†’ $300T+ debt secured by NXT reserves
    7. **ğŸ›¡ï¸ Crisis protection** â†’ F_floor drains reserve to guarantee BHLS during emergencies
    
    **The Innovation:** Messaging IS the economy - every text, link, or image creates real economic flow
    """)
    
    st.divider()
    
    # System health
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("### ğŸ“Š System Health")
        
        crisis_status = loop_status['crisis_status']
        crisis_active = crisis_status['crisis_active']
        
        if crisis_active:
            st.error(f"âš ï¸ **Crisis Active:** {', '.join(crisis_status['crisis_reasons'])}")
        else:
            st.success("âœ… **System Healthy:** All components operating normally")
        
        st.metric("Total Transition Events", loop_status['reserve_balance']['total_entries'])
        st.metric("DEX Allocations", loop_status['dex_allocations']['total_allocations'])
        st.metric("Community Stakes", loop_status['community_ownership']['total_stakes'])
    
    with col2:
        st.markdown("### ğŸŒˆ Spectral Energy Distribution")
        
        spectral_dist = loop_status['messaging_flow']['spectral_distribution']
        if spectral_dist:
            fig = go.Figure(data=[
                go.Bar(
                    x=list(spectral_dist.keys()),
                    y=list(spectral_dist.values()),
                    marker_color=['#8B00FF', '#4169E1', '#00FF00', '#FFFF00', '#FFA500', '#FF0000']
                )
            ])
            fig.update_layout(
                title="Energy by Spectral Region",
                xaxis_title="Region",
                yaxis_title="NXT Energy",
                height=300
            )
            st.plotly_chart(fig, use_container_width=True)
        else:
            st.info("No spectral data yet - send messages to generate energy distribution")


def render_messaging_flow_tab(economic_loop):
    """Messaging â†’ Reserve flow visualization"""
    
    st.subheader("ğŸ“¨ Messaging Drives Economics")
    st.caption("Every message creates orbital transitions that fund the entire ecosystem")
    
    # Simulate message burn
    st.markdown("### ğŸ’¬ Send Test Message")
    
    col1, col2 = st.columns(2)
    with col1:
        sender = st.text_input("Sender Address", "user_wallet_001")
        message_type = st.selectbox("Message Type", ["standard", "link", "image", "video"])
    
    with col2:
        burn_amount = st.number_input("NXT to Burn", min_value=0.000001, max_value=1.0, value=0.000057, step=0.000001, format="%.6f")
        wavelength = st.number_input("Wavelength (nm)", min_value=380.0, max_value=750.0, value=490.0, step=1.0)
    
    if st.button("ğŸ”¥ Send Message & Burn NXT", use_container_width=True):
        message_id = f"MSG_{int(time.time() * 1000)}"
        
        success, msg, event = economic_loop.flow_controller.process_message_burn(
            sender_address=sender,
            message_id=message_id,
            burn_amount_nxt=burn_amount,
            wavelength_nm=wavelength,
            message_type=message_type
        )
        
        if success:
            st.success(f"âœ… {msg}")
            if event:
                st.json({
                    'event_id': event.event_id,
                    'spectral_region': event.spectral_region.name,
                    'energy_joules': f"{event.energy_joules:.2e}",
                    'energy_nxt_units': event.energy_nxt_units
                })
        else:
            st.error(f"âŒ {msg}")
    
    st.divider()
    
    # Flow statistics
    flow_stats = economic_loop.flow_controller.get_flow_statistics()
    
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Total Events", flow_stats['total_events'])
    with col2:
        st.metric("Reserve Balance", f"{flow_stats['reserve_balance']['total_energy_nxt']:.4f} NXT")
    with col3:
        st.metric("Recent Activity (1hr)", flow_stats['recent_activity'])


def render_reserve_dex_tab(economic_loop):
    """Reserve â†’ DEX liquidity allocation"""
    
    st.subheader("ğŸ’§ Reserve Fuels DEX Liquidity")
    st.caption("Orbital transition energy allocated to supply-chain trading pairs")
    
    # Allocate reserves
    st.markdown("### ğŸ“Š Allocate Reserve to DEX Pools")
    
    allocation_amount = st.number_input(
        "Reserve Amount to Allocate (NXT)",
        min_value=0.1,
        max_value=10000.0,
        value=100.0,
        step=10.0
    )
    
    if st.button("ğŸ’§ Allocate to DEX Pools", use_container_width=True):
        success, msg, details = economic_loop.liquidity_allocator.allocate_reserve_to_pools(
            reserve_amount_nxt=allocation_amount
        )
        
        if success:
            st.success(f"âœ… {msg}")
            
            # Show allocation breakdown
            st.markdown("### ğŸ¯ Allocation Breakdown")
            for pool, amount in details['pools'].items():
                percentage = (amount / details['total_allocated_nxt']) * 100
                st.progress(percentage / 100, text=f"{pool}: {amount:.2f} NXT ({percentage:.1f}%)")
        else:
            st.error(f"âŒ {msg}")
    
    st.divider()
    
    # Allocation summary
    summary = economic_loop.liquidity_allocator.get_allocation_summary()
    
    st.markdown("### ğŸ“ˆ Historical Allocations")
    col1, col2 = st.columns(2)
    
    with col1:
        st.metric("Total Allocations", summary['total_allocations'])
        st.metric("Total NXT Allocated", f"{summary['total_nxt_allocated']:.2f}")
    
    with col2:
        st.markdown("#### Supply Chain Weights")
        weights = summary['supply_chain_weights']
        for industry, weight in weights.items():
            st.write(f"**{industry.title()}**: {weight*100}%")
    
    # Pool distribution chart
    if summary['pool_distribution']:
        fig = go.Figure(data=[
            go.Pie(
                labels=list(summary['pool_distribution'].keys()),
                values=list(summary['pool_distribution'].values()),
                hole=0.4
            )
        ])
        fig.update_layout(title="Pool Distribution")
        st.plotly_chart(fig, use_container_width=True)


def render_supply_chain_tab(economic_loop):
    """Supply chain value generation"""
    
    st.subheader("ğŸ­ Supply Chain Monetization")
    st.caption("Industry productivity generates NXT value via E=hf physics pricing")
    
    # Input productivity
    st.markdown("### âš™ï¸ Report Industry Productivity")
    
    col1, col2 = st.columns(2)
    with col1:
        industry = st.selectbox("Industry", ["Manufacturing", "Logistics", "Services", "Agriculture", "Technology"])
        energy_kwh = st.number_input("Energy Usage (kWh)", min_value=0.0, max_value=1000000.0, value=10000.0, step=1000.0)
    
    with col2:
        output_tonnage = st.number_input("Output (Tonnage)", min_value=0.0, max_value=100000.0, value=500.0, step=50.0)
        participants = st.number_input("Participants", min_value=1, max_value=10000, value=50, step=10)
    
    if st.button("ğŸ“Š Calculate NXT Value", use_container_width=True):
        productivity = IndustryProductivity(
            industry_type=industry,
            energy_usage_kwh=energy_kwh,
            output_tonnage=output_tonnage,
            participants=participants
        )
        
        nxt_value = economic_loop.value_oracle.calculate_nxt_value_from_productivity(productivity)
        
        st.success(f"âœ… This productivity generates **{nxt_value:.6f} NXT** value")
        
        # Distribute rewards
        if st.button("ğŸ’° Distribute Rewards to Participants"):
            # Create dummy participant addresses
            addresses = [f"participant_{i}" for i in range(participants)]
            
            success, msg, total = economic_loop.reward_engine.distribute_productivity_rewards(
                productivity, addresses
            )
            
            if success:
                st.success(f"âœ… {msg}")
    
    st.divider()
    
    # Total supply chain value
    total_value = economic_loop.value_oracle.get_total_supply_chain_value()
    st.metric("ğŸŒ Total Supply Chain NXT Value", f"{total_value:.6f} NXT")


def render_community_ownership_tab(economic_loop):
    """Community ownership ledger"""
    
    st.subheader("ğŸ¤ Community Ownership Stakes")
    st.caption("Every DEX investment creates immutable ownership sealed to the ledger")
    
    # Record ownership stake
    st.markdown("### ğŸ’ Record Ownership Stake")
    
    col1, col2 = st.columns(2)
    with col1:
        wallet = st.text_input("Wallet Address", "investor_wallet_001")
        pool = st.selectbox("Pool", ["NXT-MANUFACTURING", "NXT-LOGISTICS", "NXT-SERVICES", "NXT-AGRICULTURE", "NXT-TECHNOLOGY"])
    
    with col2:
        nxt_invested = st.number_input("NXT Invested", min_value=0.1, max_value=100000.0, value=100.0, step=10.0)
        spectral = st.selectbox("Spectral Region", [r.name for r in SpectralRegion])
    
    if st.button("ğŸ“ Record Ownership", use_container_width=True):
        spectral_region = SpectralRegion[spectral]
        lp_tokens = nxt_invested * 0.95  # 95% conversion (5% fee)
        
        stake = economic_loop.ownership_ledger.record_ownership_stake(
            wallet_address=wallet,
            pool_name=pool,
            spectral_region=spectral_region,
            nxt_invested=nxt_invested,
            lp_tokens=lp_tokens,
            energy_source_entry_id="TRE_demo_001"
        )
        
        st.success(f"âœ… Ownership stake recorded: {stake.stake_id}")
        st.json(stake.to_dict())
    
    st.divider()
    
    # Query ownership
    st.markdown("### ğŸ” Query Wallet Ownership")
    query_wallet = st.text_input("Query Wallet", "investor_wallet_001")
    
    if st.button("ğŸ” Get Ownership"):
        ownership = economic_loop.ownership_ledger.get_wallet_ownership(query_wallet)
        
        st.metric("Total Invested", f"{ownership['total_invested_nxt']:.2f} NXT")
        st.metric("Total LP Tokens", f"{ownership['total_lp_tokens']:.2f}")
        st.metric("Total Stake %", f"{ownership['total_stake_percentage']:.4f}%")
        
        if ownership['stakes']:
            st.markdown("#### Stakes:")
            for stake in ownership['stakes']:
                with st.expander(f"{stake['pool_name']} - {stake['stake_id']}"):
                    st.json(stake)


def render_crisis_protection_tab(economic_loop):
    """Crisis drain mechanism"""
    
    st.subheader("ğŸ›¡ï¸ Crisis Protection System")
    st.caption("Emergency drain routes reserve energy back to F_floor BHLS protection")
    
    # Check crisis status
    status = economic_loop.crisis_controller.get_crisis_status()
    
    if status['crisis_active']:
        st.error(f"âš ï¸ **CRISIS DETECTED:** {', '.join(status['crisis_reasons'])}")
    else:
        st.success("âœ… **System Healthy:** No crisis conditions detected")
    
    st.divider()
    
    # Manual crisis drain
    st.markdown("### ğŸš¨ Manual Crisis Drain")
    st.warning("Use only in genuine emergencies to protect BHLS")
    
    drain_amount = st.number_input(
        "Drain Amount (NXT)",
        min_value=0.1,
        max_value=100000.0,
        value=1000.0,
        step=100.0
    )
    
    if st.button("ğŸš¨ Execute Crisis Drain", use_container_width=True):
        success, msg = economic_loop.crisis_controller.execute_crisis_drain(drain_amount)
        
        if success:
            st.success(f"âœ… {msg}")
        else:
            st.error(f"âŒ {msg}")
    
    st.divider()
    
    # Drain history
    st.markdown("### ğŸ“œ Drain History")
    st.metric("Total Drain Events", status['total_drain_events'])
    st.metric("Total Drained", f"{status['total_drained_nxt']:.2f} NXT")
    
    if status['last_drain']:
        st.markdown("#### Last Drain Event")
        st.json(status['last_drain'])


def render_money_flow_diagram():
    """Visualize complete money flow"""
    
    st.subheader("ğŸ’° Complete Money Flow Diagram")
    
    st.markdown("""
    ```
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                     NEXUSOS ECONOMIC LOOP                            â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    ğŸ“¨ USER SENDS MESSAGE
         â†“ (Burns NXT)
    âš›ï¸ ORBITAL TRANSITION (n â†’ n-1)
         â†“ (Energy released)
    ğŸ’° TRANSITION_RESERVE Pool
         â†“ (Allocated by supply chain demand)
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘   DEX LIQUIDITY POOLS     â•‘
    â•‘  - Manufacturing (35%)    â•‘
    â•‘  - Logistics (25%)        â•‘
    â•‘  - Services (20%)         â•‘
    â•‘  - Agriculture (15%)      â•‘
    â•‘  - Technology (5%)        â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         â†“ (Market trading generates fees)
    ğŸ­ SUPPLY CHAIN PRODUCTIVITY
         â†“ (Industry generates NXT value)
    ğŸ’ PRODUCTIVITY REWARDS
         â†“ (Rewards to participants + LPs)
    ğŸ¤ COMMUNITY OWNERSHIP LEDGER
         â†“ (Physics-backed stakes)
    ğŸŒ GLOBAL DEBT BACKING
         â†“ ($300T+ secured by reserves)
    âš ï¸ CRISIS DETECTED? â†’ ğŸ›¡ï¸ F_FLOOR DRAIN
         â†“ (Emergency BHLS protection)
    âœ… CIVILIZATION SURVIVAL GUARANTEED
    ```
    """)
    
    st.info("""
    ### ğŸ¯ Key Principles:
    
    1. **Messaging IS the Economy** - Every text/link/image creates economic flow
    2. **Physics-Based Value** - E=hf orbital transitions, not speculation  
    3. **Supply Chain Reality** - Industry productivity adds real NXT value
    4. **Community Ownership** - Investments sealed to immutable ledger
    5. **Crisis Protection** - F_floor guarantees BHLS even in collapse
    6. **Debt Backing** - $300T+ global debt secured by reserve energy
    
    **This is fundamentally different from traditional crypto** - value comes from
    real economic productivity and messaging activity, not market speculation.
    """)


if __name__ == "__main__":
    render_economic_loop_dashboard()
